---
phase: 06-client-provisioning
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - scripts/provisioning/steps/05-n8n.ts
  - scripts/provisioning/orchestrator.ts
  - scripts/provisioning/rollback.ts
  - app/api/provisioning/route.ts
  - .env.example
autonomous: false
user_setup:
  - service: n8n
    why: "N8N API access for creating client workflows"
    env_vars:
      - name: N8N_API_KEY
        source: "N8N Dashboard (n8n.srv1114684.hstgr.cloud) -> Settings -> API -> Create API Key"
      - name: N8N_HOST
        source: "Your N8N host URL (e.g., 'n8n.srv1114684.hstgr.cloud')"
    dashboard_config:
      - task: "Enable API in N8N settings"
        location: "N8N Dashboard -> Settings -> API -> Enable API"

must_haves:
  truths:
    - "Running N8N step creates workflow with client-specific webhook path"
    - "N8N workflow is activated automatically after creation"
    - "Orchestrator runs all steps in sequence with rollback on failure"
    - "API endpoint allows triggering provisioning for new clients"
    - "Failed provisioning triggers cleanup of created resources"
  artifacts:
    - path: "scripts/provisioning/steps/05-n8n.ts"
      provides: "createN8NWorkflow function"
      exports: ["createN8NWorkflow", "activateN8NWorkflow"]
    - path: "scripts/provisioning/orchestrator.ts"
      provides: "provisionClient orchestration function"
      exports: ["provisionClient", "ProvisioningOrchestrator"]
    - path: "scripts/provisioning/rollback.ts"
      provides: "Saga rollback functions"
      exports: ["rollbackProvisioning", "rollbackActions"]
    - path: "app/api/provisioning/route.ts"
      provides: "POST endpoint to trigger provisioning"
      exports: ["POST"]
  key_links:
    - from: "scripts/provisioning/orchestrator.ts"
      to: "scripts/provisioning/steps/*.ts"
      via: "import step functions"
      pattern: "import.*from.*steps/"
    - from: "scripts/provisioning/orchestrator.ts"
      to: "scripts/provisioning/rollback.ts"
      via: "import rollbackProvisioning"
      pattern: "import.*rollbackProvisioning"
    - from: "app/api/provisioning/route.ts"
      to: "scripts/provisioning/orchestrator.ts"
      via: "import provisionClient"
      pattern: "import.*provisionClient"
---

<objective>
Create N8N webhook configuration, the main provisioning orchestrator with saga rollback, and an API endpoint to trigger client provisioning.

Purpose: This completes the provisioning pipeline by adding N8N workflow creation for each client, orchestrating all 5 steps in sequence with proper error handling and rollback, and exposing an API for triggering the entire flow.

Output: N8N workflow creation step, orchestrator that runs all steps with saga rollback on failure, cleanup functions for failed provisioning, and a protected API endpoint.
</objective>

<execution_context>
@C:\Users\Chris Terblanche\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris Terblanche\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-client-provisioning/06-RESEARCH.md

# Types and steps from 06-01 and 06-02
@lib/provisioning/types.ts
@lib/provisioning/config.ts

# Existing N8N webhook integration
@lib/n8n/webhooks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create N8N workflow provisioning step</name>
  <files>scripts/provisioning/steps/05-n8n.ts</files>
  <action>
Create the N8N workflow creation step using N8N's REST API:

```typescript
import { ProvisioningJob, ProvisioningResult } from '../../../lib/provisioning/types';

const N8N_API_BASE = `https://${process.env.N8N_HOST || 'n8n.srv1114684.hstgr.cloud'}/api/v1`;

export async function createN8NWorkflow(job: ProvisioningJob): Promise<ProvisioningResult> {
  const apiKey = process.env.N8N_API_KEY;
  const n8nHost = process.env.N8N_HOST || 'n8n.srv1114684.hstgr.cloud';

  if (!apiKey) {
    return {
      success: false,
      step: 'n8n-webhooks',
      error: 'Missing N8N_API_KEY environment variable'
    };
  }

  const workflowName = `Client ${job.clientId} - ${job.clientName}`;
  const webhookPath = `client-${job.clientId}`;

  // Check if workflow already exists (idempotency)
  const existingWorkflow = await findWorkflowByName(workflowName, apiKey);
  if (existingWorkflow) {
    console.log(`N8N workflow "${workflowName}" already exists, skipping creation`);
    return {
      success: true,
      step: 'n8n-webhooks',
      data: {
        n8nWorkflowId: existingWorkflow.id,
        n8nWebhookUrl: `https://${n8nHost}/webhook/${webhookPath}/content`
      }
    };
  }

  // Create workflow with client-specific webhook
  const workflow = {
    name: workflowName,
    nodes: [
      {
        id: 'webhook',
        name: 'Client Webhook',
        type: 'n8n-nodes-base.webhook',
        position: [250, 300],
        parameters: {
          path: `${webhookPath}/content`,
          httpMethod: 'POST',
          responseMode: 'responseNode'
        },
        typeVersion: 1
      },
      {
        id: 'response',
        name: 'Response',
        type: 'n8n-nodes-base.respondToWebhook',
        position: [500, 300],
        parameters: {},
        typeVersion: 1
      }
    ],
    connections: {
      'Client Webhook': {
        main: [[{ node: 'Response', type: 'main', index: 0 }]]
      }
    },
    settings: {
      executionOrder: 'v1'
    }
  };

  const response = await fetch(`${N8N_API_BASE}/workflows`, {
    method: 'POST',
    headers: {
      'X-N8N-API-KEY': apiKey,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(workflow)
  });

  if (!response.ok) {
    const error = await response.text();
    return {
      success: false,
      step: 'n8n-webhooks',
      error: `Failed to create N8N workflow: ${error}`
    };
  }

  const createdWorkflow = await response.json();
  console.log(`Created N8N workflow: ${createdWorkflow.id}`);

  // Activate the workflow
  await activateN8NWorkflow(createdWorkflow.id, apiKey);

  return {
    success: true,
    step: 'n8n-webhooks',
    data: {
      n8nWorkflowId: createdWorkflow.id,
      n8nWebhookUrl: `https://${n8nHost}/webhook/${webhookPath}/content`
    }
  };
}

async function findWorkflowByName(name: string, apiKey: string): Promise<{ id: string } | null> {
  const response = await fetch(`${N8N_API_BASE}/workflows`, {
    headers: { 'X-N8N-API-KEY': apiKey }
  });

  if (!response.ok) return null;

  const workflows = await response.json();
  return workflows.data?.find((w: any) => w.name === name) || null;
}

export async function activateN8NWorkflow(workflowId: string, apiKey: string): Promise<void> {
  const response = await fetch(`${N8N_API_BASE}/workflows/${workflowId}/activate`, {
    method: 'POST',
    headers: { 'X-N8N-API-KEY': apiKey }
  });

  if (response.ok) {
    console.log(`Activated N8N workflow: ${workflowId}`);
  } else {
    console.warn(`Failed to activate workflow ${workflowId}: ${await response.text()}`);
  }
}
```

Key points:
- Uses N8N REST API (not Python SDK)
- Creates workflow with client-specific webhook path
- Checks for existing workflow by name (idempotency)
- Auto-activates workflow after creation
  </action>
  <verify>
Run: `npx tsc --noEmit scripts/provisioning/steps/05-n8n.ts`
Check that it compiles with proper imports from types.ts
  </verify>
  <done>
createN8NWorkflow creates workflow with client-specific webhook.
findWorkflowByName provides idempotency check.
activateN8NWorkflow activates created workflow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create rollback and orchestrator</name>
  <files>scripts/provisioning/rollback.ts, scripts/provisioning/orchestrator.ts</files>
  <action>
Create the saga rollback functions and main orchestrator:

**scripts/provisioning/rollback.ts:**
```typescript
import { Octokit } from 'octokit';
import { CreatedResources } from '../../lib/provisioning/types';

export const rollbackActions = {
  async supabase(projectId: string): Promise<void> {
    const token = process.env.SUPABASE_MANAGEMENT_TOKEN;
    if (!token || !projectId) return;

    console.log(`Rolling back: Deleting Supabase project ${projectId}`);
    try {
      await fetch(`https://api.supabase.com/v1/projects/${projectId}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` }
      });
    } catch (error) {
      console.error(`Failed to rollback Supabase project: ${error}`);
    }
  },

  async github(repoName: string): Promise<void> {
    const token = process.env.GITHUB_TOKEN;
    const org = process.env.GITHUB_ORG;
    if (!token || !org || !repoName) return;

    console.log(`Rolling back: Deleting GitHub repo ${repoName}`);
    try {
      const octokit = new Octokit({ auth: token });
      await octokit.rest.repos.delete({ owner: org, repo: repoName });
    } catch (error) {
      console.error(`Failed to rollback GitHub repo: ${error}`);
    }
  },

  async vercel(projectId: string): Promise<void> {
    const token = process.env.VERCEL_TOKEN;
    const teamId = process.env.VERCEL_TEAM_ID;
    if (!token || !projectId) return;

    const teamQuery = teamId ? `?teamId=${teamId}` : '';
    console.log(`Rolling back: Deleting Vercel project ${projectId}`);
    try {
      await fetch(`https://api.vercel.com/v9/projects/${projectId}${teamQuery}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` }
      });
    } catch (error) {
      console.error(`Failed to rollback Vercel project: ${error}`);
    }
  },

  async n8n(workflowId: string): Promise<void> {
    const apiKey = process.env.N8N_API_KEY;
    const host = process.env.N8N_HOST || 'n8n.srv1114684.hstgr.cloud';
    if (!apiKey || !workflowId) return;

    console.log(`Rolling back: Deleting N8N workflow ${workflowId}`);
    try {
      await fetch(`https://${host}/api/v1/workflows/${workflowId}`, {
        method: 'DELETE',
        headers: { 'X-N8N-API-KEY': apiKey }
      });
    } catch (error) {
      console.error(`Failed to rollback N8N workflow: ${error}`);
    }
  }
};

export async function rollbackProvisioning(resources: CreatedResources): Promise<void> {
  console.log('Starting rollback...');

  // Reverse order: N8N -> Vercel -> GitHub -> Supabase
  if (resources.n8nWorkflowId) {
    await rollbackActions.n8n(resources.n8nWorkflowId);
  }
  if (resources.vercelProjectId) {
    await rollbackActions.vercel(resources.vercelProjectId);
  }
  if (resources.githubRepoName) {
    await rollbackActions.github(resources.githubRepoName);
  }
  if (resources.supabaseProjectId) {
    await rollbackActions.supabase(resources.supabaseProjectId);
  }

  console.log('Rollback complete');
}
```

**scripts/provisioning/orchestrator.ts:**
```typescript
import { ProvisioningJob, CreatedResources, ProvisioningResult } from '../../lib/provisioning/types';
import { validateProvisioningEnv } from '../../lib/provisioning/config';
import { createSupabaseProject } from './steps/01-supabase';
import { cloneSchemaToProject } from './steps/02-database';
import { createGitHubRepo } from './steps/03-github';
import { createVercelProject } from './steps/04-vercel';
import { createN8NWorkflow } from './steps/05-n8n';
import { rollbackProvisioning } from './rollback';

export interface ProvisioningOrchestrator {
  job: ProvisioningJob;
  createdResources: CreatedResources;
}

export async function provisionClient(
  clientId: string,
  clientName: string,
  orgEmail: string,
  tier: 'starter' | 'professional' | 'enterprise'
): Promise<{ success: boolean; resources?: CreatedResources; error?: string }> {
  // Validate env vars first
  const envCheck = validateProvisioningEnv();
  if (!envCheck.valid) {
    return {
      success: false,
      error: `Missing environment variables: ${envCheck.missing.join(', ')}`
    };
  }

  const job: ProvisioningJob = {
    clientId,
    clientName,
    orgEmail,
    tier,
    createdResources: {}
  };

  const resources: CreatedResources = {};

  try {
    // Step 1: Create Supabase project
    console.log('Step 1/5: Creating Supabase project...');
    const supabaseResult = await createSupabaseProject(job);
    if (!supabaseResult.success) {
      throw new Error(`Supabase creation failed: ${supabaseResult.error}`);
    }
    Object.assign(resources, supabaseResult.data);
    job.createdResources = { ...resources };

    // Step 2: Clone database schema
    console.log('Step 2/5: Cloning database schema...');
    if (resources.supabaseDatabaseUrl) {
      const schemaResult = await cloneSchemaToProject(
        resources.supabaseDatabaseUrl,
        resources.supabaseProjectRef || ''
      );
      if (!schemaResult.success) {
        throw new Error(`Schema cloning failed: ${schemaResult.error}`);
      }
    }

    // Step 3: Create GitHub repo
    console.log('Step 3/5: Creating GitHub repository...');
    const githubResult = await createGitHubRepo(job);
    if (!githubResult.success) {
      throw new Error(`GitHub creation failed: ${githubResult.error}`);
    }
    Object.assign(resources, githubResult.data);
    job.createdResources = { ...resources };

    // Step 4: Create Vercel deployment
    console.log('Step 4/5: Creating Vercel deployment...');
    const vercelResult = await createVercelProject(job, resources);
    if (!vercelResult.success) {
      throw new Error(`Vercel creation failed: ${vercelResult.error}`);
    }
    Object.assign(resources, vercelResult.data);
    job.createdResources = { ...resources };

    // Step 5: Configure N8N webhooks
    console.log('Step 5/5: Configuring N8N webhooks...');
    const n8nResult = await createN8NWorkflow(job);
    if (!n8nResult.success) {
      throw new Error(`N8N configuration failed: ${n8nResult.error}`);
    }
    Object.assign(resources, n8nResult.data);

    console.log('Provisioning complete!');
    return { success: true, resources };

  } catch (error) {
    console.error('Provisioning failed:', error);

    // Saga rollback
    await rollbackProvisioning(resources);

    return {
      success: false,
      resources,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}
```

Key points:
- Orchestrator validates env vars before starting
- Runs steps in sequence (not parallel - later steps need earlier outputs)
- Tracks created resources for rollback
- On any failure, calls rollbackProvisioning with all created resources
- Rollback deletes in reverse order (N8N -> Vercel -> GitHub -> Supabase)
  </action>
  <verify>
Run: `npx tsc --noEmit scripts/provisioning/orchestrator.ts scripts/provisioning/rollback.ts`
Both files compile without errors.
  </verify>
  <done>
orchestrator.ts exports provisionClient that runs all 5 steps sequentially.
rollback.ts exports rollbackProvisioning with saga pattern (reverse order).
Each rollback action handles its own errors to prevent cascade failures.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API endpoint and update env.example</name>
  <files>app/api/provisioning/route.ts, .env.example</files>
  <action>
Create the protected API endpoint and update env.example:

**app/api/provisioning/route.ts:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';
import { provisionClient } from '@/scripts/provisioning/orchestrator';
import { z } from 'zod';

const provisioningSchema = z.object({
  clientId: z.string().min(1).max(50),
  clientName: z.string().min(1).max(100),
  orgEmail: z.string().email(),
  tier: z.enum(['starter', 'professional', 'enterprise'])
});

export async function POST(request: NextRequest) {
  try {
    // Auth check - must be authenticated admin
    const supabase = await createServerClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // TODO: Add admin role check when role system is implemented
    // For now, any authenticated user can provision (restrict in production)

    // Parse and validate body
    const body = await request.json();
    const validation = provisioningSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Invalid request', details: validation.error.flatten() },
        { status: 400 }
      );
    }

    const { clientId, clientName, orgEmail, tier } = validation.data;

    // Run provisioning
    const result = await provisionClient(clientId, clientName, orgEmail, tier);

    if (!result.success) {
      return NextResponse.json(
        { error: 'Provisioning failed', details: result.error },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Client provisioned successfully',
      resources: {
        supabaseProjectId: result.resources?.supabaseProjectId,
        githubRepoUrl: result.resources?.githubRepoUrl,
        vercelDeploymentUrl: result.resources?.vercelDeploymentUrl,
        n8nWebhookUrl: result.resources?.n8nWebhookUrl
      }
    });

  } catch (error) {
    console.error('Provisioning API error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**Update .env.example** - add new provisioning variables:
```env
# Client Provisioning (Phase 6)
# Supabase Management API - get from Account Settings -> Access Tokens
SUPABASE_MANAGEMENT_TOKEN=your_management_token
SUPABASE_ORG_ID=your_organization_id

# GitHub - get from Settings -> Developer settings -> Personal access tokens
GITHUB_TOKEN=your_github_token
GITHUB_ORG=draggonnb
GITHUB_TEMPLATE_REPO=client-template

# Vercel - get from Settings -> Tokens
VERCEL_TOKEN=your_vercel_token
VERCEL_TEAM_ID=optional_team_id

# N8N API - get from N8N Settings -> API
N8N_API_KEY=your_n8n_api_key
N8N_HOST=n8n.srv1114684.hstgr.cloud
```

Read existing .env.example first and append these new variables.
  </action>
  <verify>
Run: `npx tsc --noEmit app/api/provisioning/route.ts`
Check .env.example contains all new provisioning variables.
Run: `npm run build` - full build passes
  </verify>
  <done>
API endpoint at POST /api/provisioning accepts clientId, clientName, orgEmail, tier.
Endpoint validates auth and input with zod.
.env.example documents all required provisioning env vars.
  </done>
</task>

</tasks>

<verification>
1. All TypeScript files compile: `npx tsc --noEmit scripts/provisioning/*.ts app/api/provisioning/route.ts`
2. Build passes: `npm run build`
3. .env.example updated: `grep "SUPABASE_MANAGEMENT_TOKEN" .env.example`
4. Orchestrator imports all steps correctly
5. Rollback imports correctly from orchestrator
</verification>

<success_criteria>
- [ ] scripts/provisioning/steps/05-n8n.ts exports createN8NWorkflow, activateN8NWorkflow
- [ ] scripts/provisioning/rollback.ts exports rollbackProvisioning, rollbackActions
- [ ] scripts/provisioning/orchestrator.ts exports provisionClient, ProvisioningOrchestrator
- [ ] app/api/provisioning/route.ts exports POST handler with auth check
- [ ] .env.example contains all 9 new provisioning env vars
- [ ] Orchestrator runs steps in order: Supabase -> Schema -> GitHub -> Vercel -> N8N
- [ ] Rollback runs in reverse order: N8N -> Vercel -> GitHub -> Supabase
- [ ] npm run build passes
</success_criteria>

<checkpoint type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete client provisioning pipeline with Supabase, GitHub, Vercel, and N8N automation</what-built>
  <how-to-verify>
    1. Review the orchestrator flow: scripts/provisioning/orchestrator.ts
    2. Verify rollback order is reverse of creation order
    3. Check API endpoint has auth protection
    4. Confirm .env.example has all required variables documented
    5. Run `npm run build` to verify compilation

    Note: Full end-to-end testing requires setting up all API credentials (Supabase Management, GitHub, Vercel, N8N). The code structure and flow can be verified without credentials.
  </how-to-verify>
  <resume-signal>Type "approved" if the provisioning pipeline structure looks correct, or describe any issues</resume-signal>
</checkpoint>

<output>
After completion, create `.planning/phases/06-client-provisioning/06-03-SUMMARY.md`
</output>
