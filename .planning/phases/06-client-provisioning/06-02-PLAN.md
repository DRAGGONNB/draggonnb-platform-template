---
phase: 06-client-provisioning
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - scripts/provisioning/steps/03-github.ts
  - scripts/provisioning/steps/04-vercel.ts
autonomous: true
user_setup:
  - service: github
    why: "GitHub API access for creating repos from template"
    env_vars:
      - name: GITHUB_TOKEN
        source: "GitHub -> Settings -> Developer settings -> Personal access tokens -> Generate new token (classic) with repo scope"
      - name: GITHUB_ORG
        source: "Your GitHub organization name (e.g., 'draggonnb')"
      - name: GITHUB_TEMPLATE_REPO
        source: "Name of template repository (e.g., 'client-template')"
    dashboard_config:
      - task: "Create template repository"
        location: "GitHub -> New Repository -> Check 'Template repository' in settings"
  - service: vercel
    why: "Vercel API access for creating deployments"
    env_vars:
      - name: VERCEL_TOKEN
        source: "Vercel Dashboard -> Settings -> Tokens -> Create Token"
      - name: VERCEL_TEAM_ID
        source: "Vercel Dashboard -> Settings -> General -> Team ID (optional, omit for personal account)"

must_haves:
  truths:
    - "Running GitHub step creates new private repo from template"
    - "GitHub repo has client-specific name (client-{id}-app)"
    - "Running Vercel step creates project linked to GitHub repo"
    - "Vercel deployment has all required env vars set before first build"
    - "Steps are idempotent - re-running skips existing resources"
  artifacts:
    - path: "scripts/provisioning/steps/03-github.ts"
      provides: "createGitHubRepo function with idempotency"
      exports: ["createGitHubRepo", "checkRepoExists"]
    - path: "scripts/provisioning/steps/04-vercel.ts"
      provides: "createVercelProject and setVercelEnvVars functions"
      exports: ["createVercelProject", "setVercelEnvVars", "triggerVercelDeployment"]
  key_links:
    - from: "scripts/provisioning/steps/03-github.ts"
      to: "GitHub API"
      via: "Octokit SDK"
      pattern: "octokit\\.rest\\.repos"
    - from: "scripts/provisioning/steps/04-vercel.ts"
      to: "Vercel API"
      via: "fetch with VERCEL_TOKEN"
      pattern: "api\\.vercel\\.com"
    - from: "scripts/provisioning/steps/04-vercel.ts"
      to: "lib/provisioning/types.ts"
      via: "import CreatedResources"
      pattern: "import.*CreatedResources"
---

<objective>
Create GitHub repository and Vercel deployment automation for new client infrastructure.

Purpose: Each client gets their own GitHub repo (for code isolation and customization) and Vercel deployment (for isolated hosting). The GitHub repo is created from a template, and Vercel is configured with the client's Supabase credentials before the first build.

Output: GitHub repo creation step using Octokit SDK, Vercel project creation and environment variable configuration step.
</objective>

<execution_context>
@C:\Users\Chris Terblanche\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris Terblanche\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-client-provisioning/06-RESEARCH.md

# Types created in 06-01
@lib/provisioning/types.ts
@lib/provisioning/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub repository provisioning step</name>
  <files>scripts/provisioning/steps/03-github.ts</files>
  <action>
Install Octokit and create the GitHub repo creation step:

1. Install: `npm install octokit`

2. Create the step with idempotency:

```typescript
import { Octokit } from 'octokit';
import { ProvisioningJob, ProvisioningResult } from '../../../lib/provisioning/types';

export async function checkRepoExists(
  octokit: Octokit,
  owner: string,
  repoName: string
): Promise<boolean> {
  try {
    await octokit.rest.repos.get({ owner, repo: repoName });
    return true;
  } catch (error: any) {
    if (error.status === 404) return false;
    throw error;
  }
}

export async function createGitHubRepo(job: ProvisioningJob): Promise<ProvisioningResult> {
  const token = process.env.GITHUB_TOKEN;
  const org = process.env.GITHUB_ORG;
  const templateRepo = process.env.GITHUB_TEMPLATE_REPO;

  if (!token || !org || !templateRepo) {
    return {
      success: false,
      step: 'github-repo',
      error: 'Missing GitHub environment variables (GITHUB_TOKEN, GITHUB_ORG, GITHUB_TEMPLATE_REPO)'
    };
  }

  const octokit = new Octokit({ auth: token });
  const repoName = `client-${job.clientId}-app`;

  // Idempotency: Check if repo already exists
  const exists = await checkRepoExists(octokit, org, repoName);
  if (exists) {
    console.log(`Repository ${repoName} already exists, skipping creation`);
    return {
      success: true,
      step: 'github-repo',
      data: {
        githubRepoName: repoName,
        githubRepoUrl: `https://github.com/${org}/${repoName}`
      }
    };
  }

  // Create from template
  const { data: repo } = await octokit.rest.repos.createUsingTemplate({
    template_owner: org,
    template_repo: templateRepo,
    owner: org,
    name: repoName,
    private: true,
    description: `Client ${job.clientId} (${job.clientName}) - DraggonnB CRMM`,
    include_all_branches: false
  });

  console.log(`Created repository: ${repo.html_url}`);

  return {
    success: true,
    step: 'github-repo',
    data: {
      githubRepoName: repo.name,
      githubRepoUrl: repo.html_url
    }
  };
}
```

Key points:
- Use Octokit SDK (not raw fetch) for auth, rate limits, retries
- Check repo exists before creating (idempotency)
- Create as private repo
- Use `createUsingTemplate` not fork
- Only copy main branch (include_all_branches: false)
  </action>
  <verify>
Run: `npm ls octokit` - package installed
Run: `npx tsc --noEmit scripts/provisioning/steps/03-github.ts` - compiles
  </verify>
  <done>
createGitHubRepo creates private repo from template with idempotency check.
checkRepoExists helper exported for reuse.
Uses Octokit SDK with proper error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Vercel deployment provisioning step</name>
  <files>scripts/provisioning/steps/04-vercel.ts</files>
  <action>
Create the Vercel project creation and deployment step:

```typescript
import { backOff } from 'exponential-backoff';
import { ProvisioningJob, ProvisioningResult, CreatedResources } from '../../../lib/provisioning/types';

const VERCEL_API = 'https://api.vercel.com';

interface VercelEnvVar {
  key: string;
  value: string;
  type: 'encrypted' | 'plain';
  target: ('production' | 'preview' | 'development')[];
}

export async function createVercelProject(
  job: ProvisioningJob,
  supabaseCredentials: Partial<CreatedResources>
): Promise<ProvisioningResult> {
  const token = process.env.VERCEL_TOKEN;
  const teamId = process.env.VERCEL_TEAM_ID;
  const githubOrg = process.env.GITHUB_ORG;

  if (!token) {
    return {
      success: false,
      step: 'vercel-deployment',
      error: 'Missing VERCEL_TOKEN environment variable'
    };
  }

  const repoName = job.createdResources?.githubRepoName || `client-${job.clientId}-app`;
  const projectName = repoName;

  // Build query string for team (optional)
  const teamQuery = teamId ? `?teamId=${teamId}` : '';

  // Step 1: Check if project exists (idempotency)
  const existsResponse = await fetch(
    `${VERCEL_API}/v9/projects/${projectName}${teamQuery}`,
    { headers: { Authorization: `Bearer ${token}` } }
  );

  if (existsResponse.ok) {
    const existing = await existsResponse.json();
    console.log(`Vercel project ${projectName} already exists, skipping creation`);
    return {
      success: true,
      step: 'vercel-deployment',
      data: {
        vercelProjectId: existing.id,
        vercelDeploymentUrl: `https://${projectName}.vercel.app`
      }
    };
  }

  // Step 2: Create project linked to GitHub repo
  const createResponse = await fetch(
    `${VERCEL_API}/v9/projects${teamQuery}`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: projectName,
        gitRepository: {
          repo: `${githubOrg}/${repoName}`,
          type: 'github'
        },
        framework: 'nextjs',
        buildCommand: 'npm run build',
        outputDirectory: '.next'
      })
    }
  );

  if (!createResponse.ok) {
    const error = await createResponse.text();
    return {
      success: false,
      step: 'vercel-deployment',
      error: `Failed to create Vercel project: ${error}`
    };
  }

  const project = await createResponse.json();
  console.log(`Created Vercel project: ${project.id}`);

  // Step 3: Set environment variables BEFORE first deployment
  const envVars: VercelEnvVar[] = [
    { key: 'NEXT_PUBLIC_SUPABASE_URL', value: `https://${supabaseCredentials.supabaseProjectRef}.supabase.co`, type: 'plain', target: ['production', 'preview'] },
    { key: 'NEXT_PUBLIC_SUPABASE_ANON_KEY', value: supabaseCredentials.supabaseAnonKey || '', type: 'encrypted', target: ['production', 'preview'] },
    { key: 'SUPABASE_SERVICE_ROLE_KEY', value: supabaseCredentials.supabaseServiceRoleKey || '', type: 'encrypted', target: ['production'] },
    { key: 'NEXT_PUBLIC_APP_URL', value: `https://${projectName}.vercel.app`, type: 'plain', target: ['production', 'preview'] }
  ];

  await setVercelEnvVars(project.id, envVars, token, teamId);

  // Step 4: Trigger initial deployment
  const deployResult = await triggerVercelDeployment(project.id, repoName, githubOrg || '', token, teamId);

  return {
    success: true,
    step: 'vercel-deployment',
    data: {
      vercelProjectId: project.id,
      vercelDeploymentUrl: deployResult.url || `https://${projectName}.vercel.app`
    }
  };
}

export async function setVercelEnvVars(
  projectId: string,
  envVars: VercelEnvVar[],
  token: string,
  teamId?: string
): Promise<void> {
  const teamQuery = teamId ? `?teamId=${teamId}` : '';

  for (const envVar of envVars) {
    if (!envVar.value) {
      console.warn(`Skipping empty env var: ${envVar.key}`);
      continue;
    }

    const response = await fetch(
      `${VERCEL_API}/v10/projects/${projectId}/env${teamQuery}`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(envVar)
      }
    );

    if (!response.ok) {
      console.error(`Failed to set env var ${envVar.key}: ${await response.text()}`);
    } else {
      console.log(`Set env var: ${envVar.key}`);
    }
  }
}

export async function triggerVercelDeployment(
  projectId: string,
  repoName: string,
  githubOrg: string,
  token: string,
  teamId?: string
): Promise<{ url?: string; id?: string }> {
  const teamQuery = teamId ? `?teamId=${teamId}` : '';

  const response = await fetch(
    `${VERCEL_API}/v13/deployments${teamQuery}`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: repoName,
        gitSource: {
          type: 'github',
          repo: `${githubOrg}/${repoName}`,
          ref: 'main'
        }
      })
    }
  );

  if (!response.ok) {
    console.error(`Failed to trigger deployment: ${await response.text()}`);
    return {};
  }

  const deployment = await response.json();
  console.log(`Triggered deployment: ${deployment.id}`);

  return { url: deployment.url, id: deployment.id };
}
```

Key points:
- Set env vars BEFORE triggering deployment (prevents broken first build)
- Use encrypted type for secrets (anon key, service role key)
- Check if project exists before creating (idempotency)
- Support optional team ID for Vercel teams
  </action>
  <verify>
Run: `npx tsc --noEmit scripts/provisioning/steps/04-vercel.ts` - compiles
Check imports work: types from lib/provisioning/types.ts
  </verify>
  <done>
createVercelProject creates project linked to GitHub with idempotency.
setVercelEnvVars sets Supabase credentials before first build.
triggerVercelDeployment kicks off initial deployment.
Env vars use encrypted type for secrets.
  </done>
</task>

</tasks>

<verification>
1. Octokit installed: `npm ls octokit`
2. All files compile: `npx tsc --noEmit scripts/provisioning/steps/03-github.ts scripts/provisioning/steps/04-vercel.ts`
3. Imports work correctly (types from 06-01)
4. npm run build passes
</verification>

<success_criteria>
- [ ] octokit package installed
- [ ] scripts/provisioning/steps/03-github.ts exports createGitHubRepo, checkRepoExists
- [ ] scripts/provisioning/steps/04-vercel.ts exports createVercelProject, setVercelEnvVars, triggerVercelDeployment
- [ ] GitHub step has idempotency check (checkRepoExists before create)
- [ ] Vercel step has idempotency check (GET project before create)
- [ ] Vercel env vars set BEFORE deployment triggered
- [ ] npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-client-provisioning/06-02-SUMMARY.md`
</output>
