---
phase: 02-core-module-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/email/campaigns/[id]/send/route.ts
  - lib/email/resend.ts
autonomous: true
user_setup:
  - service: resend
    why: "Email sending requires Resend API key"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
    dashboard_config: []

must_haves:
  truths:
    - "Campaign send targets contacts table (CRM leads), not users table (team members)"
    - "Campaign send uses Resend batch API for efficient sending"
    - "Campaigns with 100+ recipients do not timeout"
    - "Email sending gracefully handles missing RESEND_API_KEY with 503 response"
  artifacts:
    - path: "app/api/email/campaigns/[id]/send/route.ts"
      provides: "Campaign send endpoint targeting contacts with batch API"
      contains: "from('contacts')"
    - path: "lib/email/resend.ts"
      provides: "Batch email sending function"
      exports: ["sendBatchEmails"]
  key_links:
    - from: "app/api/email/campaigns/[id]/send/route.ts"
      to: "supabase.from('contacts')"
      via: "recipient query"
      pattern: "\\.from\\(['\"]contacts['\"]\\)"
    - from: "app/api/email/campaigns/[id]/send/route.ts"
      to: "lib/email/resend.ts"
      via: "sendBatchEmails import"
      pattern: "sendBatchEmails"
---

<objective>
Fix email campaign sending to target CRM contacts and use batch API for efficiency.

Purpose: The campaign send route currently queries the `users` table (team members) instead of the `contacts` table (CRM leads/customers), and sends emails one-by-one in a for-loop which times out for 100+ recipients. This plan fixes both issues.

Output: Campaign send route that queries contacts table, uses Resend batch API, and handles batches of 100 emails efficiently.
</objective>

<execution_context>
@C:\Users\Chris Terblanche\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris Terblanche\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-module-completion/02-RESEARCH.md

# Relevant source files
@app/api/email/campaigns/[id]/send/route.ts
@lib/email/resend.ts
@lib/email/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update campaign send to target contacts table</name>
  <files>app/api/email/campaigns/[id]/send/route.ts</files>
  <action>
Fix the recipient query to target contacts instead of users:

1. **Find the recipients query (around line 110-114):**
   Current code:
   ```typescript
   const { data: recipients, error: recipientsError } = await supabase
     .from('users')
     .select('id, email, full_name')
     .eq('organization_id', organizationId)
   ```

2. **Replace with contacts query:**
   ```typescript
   const { data: recipients, error: recipientsError } = await supabase
     .from('contacts')
     .select('id, email, first_name, last_name')
     .eq('organization_id', organizationId)
     .eq('status', 'active')  // Only send to active contacts
   ```

3. **Update variable extraction (around line 170-180):**
   Change from parsing full_name to using first_name/last_name directly:
   ```typescript
   const variables = {
     first_name: recipient.first_name || '',
     last_name: recipient.last_name || '',
     full_name: `${recipient.first_name || ''} ${recipient.last_name || ''}`.trim(),
     email: recipient.email,
     unsubscribe_url: generateUnsubscribeUrl(organizationId, recipient.email),
     preferences_url: generatePreferencesUrl(organizationId, recipient.email),
     current_year: new Date().getFullYear().toString(),
   }
   ```

4. **Update email_sends insert (around line 187-203):**
   Change `recipient_name` from `recipient.full_name` to computed full name:
   ```typescript
   recipient_name: `${recipient.first_name || ''} ${recipient.last_name || ''}`.trim() || null,
   ```

   Remove or update `recipient_user_id` field since contacts don't have user IDs:
   - If recipient_user_id column is required, set to null
   - If not required, remove the field entirely

5. **Add comment explaining the change:**
   ```typescript
   // Query CONTACTS (CRM leads/customers), not USERS (team members)
   // Users table contains team members who should not receive marketing emails
   ```

IMPORTANT: Keep all existing error handling, limit checks, and tracking logic intact.
  </action>
  <verify>grep -n "from('contacts')" app/api/email/campaigns/\[id\]/send/route.ts returns a match; grep "from('users')" in same file returns NO match for recipient query (users query for org lookup is OK)</verify>
  <done>Campaign send queries contacts table with first_name/last_name fields, only active contacts</done>
</task>

<task type="auto">
  <name>Task 2: Implement batch sending with Resend batch API</name>
  <files>app/api/email/campaigns/[id]/send/route.ts</files>
  <action>
Replace the sequential for-loop sending with batch API:

1. **Add sendBatchEmails to imports (line 3-11):**
   Ensure sendBatchEmails is imported:
   ```typescript
   import {
     sendEmail,
     sendBatchEmails,  // ADD THIS
     renderTemplate,
     addEmailTracking,
     generateUnsubscribeUrl,
     generatePreferencesUrl,
     htmlToPlainText,
     isProviderConfigured,
   } from '@/lib/email/resend'
   ```

2. **Replace the sequential sending loop (lines 164-252):**
   The current code does:
   ```typescript
   for (const recipient of activeRecipients) {
     // ... prepare variables
     // ... create send record
     // ... await sendEmail() one at a time
   }
   ```

   Replace with batch preparation + batch sending:
   ```typescript
   // Prepare all email requests first
   const emailRequests: Array<{
     request: SendEmailRequest
     sendRecordId: string
     recipientEmail: string
   }> = []

   for (const recipient of activeRecipients) {
     // Prepare variables
     const variables = {
       first_name: recipient.first_name || '',
       last_name: recipient.last_name || '',
       full_name: `${recipient.first_name || ''} ${recipient.last_name || ''}`.trim(),
       email: recipient.email,
       unsubscribe_url: generateUnsubscribeUrl(organizationId, recipient.email),
       preferences_url: generatePreferencesUrl(organizationId, recipient.email),
       current_year: new Date().getFullYear().toString(),
     }

     // Render template
     let renderedHtml = renderTemplate(htmlContent, variables)
     const renderedSubject = renderTemplate(campaign.subject, variables)

     // Create email send record
     const { data: sendRecord } = await supabase
       .from('email_sends')
       .insert({
         organization_id: organizationId,
         campaign_id: id,
         recipient_email: recipient.email,
         recipient_name: `${recipient.first_name || ''} ${recipient.last_name || ''}`.trim() || null,
         subject: renderedSubject,
         from_email: process.env.EMAIL_FROM || 'noreply@draggonnb.app',
         from_name: process.env.EMAIL_FROM_NAME || 'DraggonnB CRMM',
         status: 'queued',
         provider: 'resend',
         metadata: { campaign_id: id },
       })
       .select('id')
       .single()

     if (!sendRecord) continue

     // Add tracking to HTML
     renderedHtml = addEmailTracking(renderedHtml, sendRecord.id)

     emailRequests.push({
       request: {
         to: recipient.email,
         subject: renderedSubject,
         html: renderedHtml,
         text: htmlToPlainText(renderedHtml),
       },
       sendRecordId: sendRecord.id,
       recipientEmail: recipient.email,
     })
   }

   // Send in batches of 100 (Resend limit)
   const BATCH_SIZE = 100
   let successCount = 0

   for (let i = 0; i < emailRequests.length; i += BATCH_SIZE) {
     const batch = emailRequests.slice(i, i + BATCH_SIZE)
     const batchRequests = batch.map(item => item.request)

     const results = await sendBatchEmails(batchRequests)

     // Update send records with results
     for (let j = 0; j < results.length; j++) {
       const result = results[j]
       const item = batch[j]

       if (result.success) {
         await supabase
           .from('email_sends')
           .update({
             status: 'sent',
             sent_at: new Date().toISOString(),
             provider_message_id: result.messageId,
           })
           .eq('id', item.sendRecordId)
         successCount++
       } else {
         await supabase
           .from('email_sends')
           .update({
             status: 'failed',
             failed_at: new Date().toISOString(),
             error_message: result.error,
           })
           .eq('id', item.sendRecordId)
       }
     }
   }
   ```

3. **Add type import at top of file:**
   ```typescript
   import type { SendEmailRequest } from '@/lib/email/types'
   ```

4. **Keep the campaign status update and usage metrics update at the end unchanged.**

IMPORTANT: The batch API sends up to 100 emails per request. For campaigns with 100+ recipients, this loops through batches but each batch is a single API call (much faster than 100 individual calls).
  </action>
  <verify>grep -n "sendBatchEmails" app/api/email/campaigns/\[id\]/send/route.ts returns matches; grep "BATCH_SIZE" returns a match; npm run build passes</verify>
  <done>Campaign send uses batch API with BATCH_SIZE of 100, processes results and updates send records</done>
</task>

<task type="auto">
  <name>Task 3: Add graceful fallback logging when Resend not configured</name>
  <files>lib/email/resend.ts</files>
  <action>
Enhance the sendBatchEmails function to log emails when RESEND_API_KEY is not configured (useful for development):

1. **Update sendBatchEmails function (around line 95):**
   Add a check at the start of the function:
   ```typescript
   export async function sendBatchEmails(
     requests: SendEmailRequest[]
   ): Promise<SendEmailResponse[]> {
     // Check if Resend is configured
     if (!RESEND_API_KEY) {
       console.warn('[Email] RESEND_API_KEY not configured. Logging emails instead of sending.')
       console.log(`[Email] Would send ${requests.length} emails:`)
       requests.forEach((req, i) => {
         console.log(`  [${i + 1}] To: ${Array.isArray(req.to) ? req.to.join(', ') : req.to}`)
         console.log(`       Subject: ${req.subject}`)
       })
       // Return success for all (simulated send)
       return requests.map((_, index) => ({
         success: true,
         messageId: `dev-${Date.now()}-${index}`,
       }))
     }

     const resend = getResendClient()
     // ... rest of existing code
   ```

2. **This allows development without Resend API key:**
   - Emails are logged to console instead of sent
   - Campaign send still "succeeds" so flow can be tested
   - Production deployments with RESEND_API_KEY will send real emails

3. **Keep isProviderConfigured() unchanged** - the route handler already returns 503 when not configured, but this fallback makes development easier.

IMPORTANT: Keep all existing batch sending logic intact. This is just adding a development-friendly fallback at the start of the function.
  </action>
  <verify>grep -n "Would send" lib/email/resend.ts returns a match; npm run build passes</verify>
  <done>sendBatchEmails logs emails to console when RESEND_API_KEY not configured, returns simulated success</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   npm run build
   ```
   Must pass with no errors.

2. **Contacts table verification:**
   ```bash
   grep -n "from('contacts')" app/api/email/campaigns/\[id\]/send/route.ts
   ```
   Should return at least one match for recipient query.

3. **No users table for recipients:**
   ```bash
   grep -n "from('users')" app/api/email/campaigns/\[id\]/send/route.ts | grep -v organization_id
   ```
   Should NOT match the recipient query (users query for getting user's org is acceptable).

4. **Batch API verification:**
   ```bash
   grep -n "sendBatchEmails" app/api/email/campaigns/\[id\]/send/route.ts
   ```
   Should return matches showing batch API is imported and used.

5. **Batch size constant:**
   ```bash
   grep -n "BATCH_SIZE" app/api/email/campaigns/\[id\]/send/route.ts
   ```
   Should return a match.
</verification>

<success_criteria>
- Campaign send route queries `contacts` table instead of `users` table
- Campaign send uses sendBatchEmails function for efficient sending
- Emails are sent in batches of 100 (Resend limit)
- Send records are updated with batch results (success/failure)
- Development mode logs emails when RESEND_API_KEY not configured
- npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-module-completion/02-02-SUMMARY.md`
</output>
