---
phase: 04-n8n-automation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - app/api/content/generate/route.ts
  - app/(dashboard)/content-generator/page.tsx
  - app/api/content/queue/route.ts
autonomous: true

must_haves:
  truths:
    - "User can enter a topic and generate AI content"
    - "Generated content displays in the UI with platform tabs"
    - "User can save generated content to queue"
    - "Content queue stores posts with correct organization_id"
  artifacts:
    - path: "app/api/content/generate/route.ts"
      provides: "API route calling N8N webhook"
      exports: ["POST"]
      contains: "N8N_BASE_URL"
    - path: "app/api/content/queue/route.ts"
      provides: "Content queue CRUD operations"
      exports: ["POST", "GET"]
    - path: "app/(dashboard)/content-generator/page.tsx"
      provides: "Content generator UI"
      min_lines: 300
  key_links:
    - from: "app/(dashboard)/content-generator/page.tsx"
      to: "/api/content/generate"
      via: "fetch POST"
      pattern: "fetch.*api/content/generate"
    - from: "app/api/content/generate/route.ts"
      to: "N8N webhook"
      via: "fetch to n8nWebhookUrl"
      pattern: "N8N_BASE_URL"
    - from: "app/(dashboard)/content-generator/page.tsx"
      to: "/api/content/queue"
      via: "fetch POST on save"
      pattern: "fetch.*api/content/queue"
---

<objective>
Wire the content generator UI to the N8N AI workflow so users can generate and save social media content.

Purpose: The UI and API route exist but the response format from N8N may not match what the UI expects. This plan ensures the full flow works: user enters topic -> API calls N8N -> N8N returns AI content -> UI displays content -> user saves to queue.

Output: Working content generator that produces AI-written posts via Claude and saves them to the content queue.
</objective>

<execution_context>
@C:\Users\Chris Terblanche\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Chris Terblanche\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-n8n-automation/04-RESEARCH.md
@.planning/phases/04-n8n-automation/04-01-SUMMARY.md

@app/api/content/generate/route.ts
@app/(dashboard)/content-generator/page.tsx
@lib/n8n/webhooks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Align API response format with UI expectations</name>
  <files>app/api/content/generate/route.ts</files>
  <action>
The content generator UI expects a response with this structure:
```typescript
{
  success: boolean
  data?: {
    contents: Array<{
      platform: string
      content: string
      hashtags?: string[]
      imagePrompt?: string
    }>
  }
  usage?: { current: number, limit: number }
  error?: string
}
```

The N8N workflow returns:
```json
{
  "success": true,
  "data": {
    "content": "...",
    "post_id": "..."
  }
}
```

Update the API route to transform the N8N response into the UI-expected format:

1. Parse the N8N response
2. The N8N response has a single "content" field with all content for all platforms
3. Transform it into the `contents` array format:
   - Split content by platform if N8N generates multi-platform content
   - Or duplicate content for each requested platform
   - Extract hashtags from content (look for # patterns)
4. Return the transformed response

Also add error handling for:
- N8N timeout (set fetch timeout to 60 seconds)
- N8N returning non-JSON response
- Missing ANTHROPIC credentials in N8N (workflow returns error)

Update the fetch call to include a timeout:
```typescript
const controller = new AbortController()
const timeoutId = setTimeout(() => controller.abort(), 60000)
const n8nResponse = await fetch(n8nWebhookUrl, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({...}),
  signal: controller.signal,
})
clearTimeout(timeoutId)
```
  </action>
  <verify>
npm run build
grep -A5 "contents:" app/api/content/generate/route.ts
  </verify>
  <done>
API route transforms N8N response into UI-expected format. Timeout handling prevents hung requests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create content queue API route</name>
  <files>app/api/content/queue/route.ts</files>
  <action>
The content generator page calls `/api/content/queue` to save generated content, but this route may not exist or may be incomplete.

Create or update `app/api/content/queue/route.ts` with:

**POST handler** - Save content to queue:
```typescript
export async function POST(request: Request) {
  // 1. Authenticate user
  const supabase = await createClient()
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) return 401

  // 2. Get organization_id
  const { data: userData } = await supabase
    .from('users')
    .select('organization_id')
    .eq('id', user.id)
    .single()

  // 3. Parse body: { platform, content, status, scheduled_for? }
  const { platform, content, status, scheduled_for } = await request.json()

  // 4. Validate required fields
  if (!platform || !content) return 400

  // 5. Insert into social_posts table
  const { data, error } = await supabase
    .from('social_posts')
    .insert({
      organization_id: userData.organization_id,
      platforms: [platform],
      content,
      status: status || 'draft',
      scheduled_for: scheduled_for || null,
      created_at: new Date().toISOString(),
    })
    .select()
    .single()

  // 6. Return created post
  return NextResponse.json({ success: true, data })
}
```

**GET handler** - List queued content:
```typescript
export async function GET(request: Request) {
  // 1. Authenticate user
  // 2. Get organization_id
  // 3. Parse query params: status filter, limit
  const url = new URL(request.url)
  const status = url.searchParams.get('status')
  const limit = parseInt(url.searchParams.get('limit') || '50')

  // 4. Query social_posts for this organization
  let query = supabase
    .from('social_posts')
    .select('*')
    .eq('organization_id', userData.organization_id)
    .order('created_at', { ascending: false })
    .limit(limit)

  if (status) {
    query = query.eq('status', status)
  }

  const { data, error } = await query

  return NextResponse.json({ success: true, data })
}
```

Use the same patterns as other API routes in the codebase (createClient from @/lib/supabase/server).
  </action>
  <verify>
test -f app/api/content/queue/route.ts
npm run build
  </verify>
  <done>
Content queue API route exists with POST (save) and GET (list) handlers. Authentication and org filtering in place.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test full content generation flow</name>
  <files>(no files modified - verification only)</files>
  <action>
Run the dev server and manually test the full flow:

1. Start dev server: `npm run dev`
2. Login to the app at http://localhost:3000
3. Navigate to Content Generator (/content-generator)
4. Enter a topic: "Benefits of cloud automation for South African SMEs"
5. Select platforms: LinkedIn
6. Click "Generate Content"
7. Verify:
   - Loading spinner appears
   - After 10-30 seconds, AI-generated content displays
   - Content has professional tone
   - Hashtags section shows relevant hashtags
8. Click "Save to Queue"
9. Verify success message appears

If any step fails:
- Check browser console for errors
- Check server console for API errors
- Check N8N Executions tab for workflow errors

Document any issues found and fix them before completing.
  </action>
  <verify>
Dev server runs without errors.
Content generator page loads.
Generate button triggers API call (visible in Network tab).
  </verify>
  <done>
Full content generation flow works: topic -> AI content -> save to queue. All integrations verified.
  </done>
</task>

</tasks>

<verification>
1. Content generator API returns properly formatted response
2. Content queue API accepts POST requests to save content
3. UI displays generated content with platform tabs
4. Save to queue creates record in social_posts table
5. npm run build passes
</verification>

<success_criteria>
- User can generate AI content from the content generator page
- Generated content displays correctly in the UI
- User can save content to queue (creates social_posts record)
- No console errors during the flow
- Response includes platform-specific content formatting
</success_criteria>

<output>
After completion, create `.planning/phases/04-n8n-automation/04-02-SUMMARY.md`
</output>
